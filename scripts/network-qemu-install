#!/usr/bin/env python3
#
# Copyright (C) 2019-2022, VyOS maintainers and contributors
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or later as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# File: check-qemu-install
# Purpose:
#  This script installs a system on a emulated qemu host to verify
#  that the iso produced is installable and boots.
#  after the iso is booted from disk it also tries to execute the
#  vyos-smoketest script to verify checks there.
#
#  For now it will not fail on failed smoketest but will fail on
#  install and boot errors.
#  Arguments:
#    iso            iso image to install
#    [disk]         disk filename to use, if none is provided it
#                   is autogenerated
#    [--keep]       Keep the disk image after completion
#    [--logfile]    name of logfile to save, defaulting to stdout
#    [--silent]     only print on errors
#    [--debug]      print all communication with the device

import pexpect
import sys
import os
import pwd
import time
import argparse
import subprocess
import random
import traceback
import logging
import re
import toml
import threading

from io import BytesIO
from io import StringIO
from datetime import datetime

# Variables
agents = {}
disk_prefix = 'testinstall-{}-{}'.format(datetime.now().strftime('%Y%m%d-%H%M%S'), "%04x" % random.randint(0,65535))
op_mode_prompt = r'vyos@vyos:~\$'
cfg_mode_prompt = r'vyos@vyos#'
default_user = 'vyos'
default_password = 'vyos'
install_states = {}
ready_states = {}
test_timeout = 3 *3600 # 3 hours (in seconds)
EXCEPTION = 0
# End Variables

parser = argparse.ArgumentParser(description='Install and start a network test VyOS vm.')
parser.add_argument('iso', help='ISO file to install')
parser.add_argument('--agents', help='Number of agents to spawn', default='1')
parser.add_argument('--keep', help='Do not remove disk-image after installation',
                              action='store_true', default=False)
parser.add_argument('--silent', help='Do not show output on stdout unless an error has occured',
                              action='store_true', default=False)
parser.add_argument('--debug', help='Send all debug output to stdout',
                               action='store_true', default=False)
parser.add_argument('--logfile', help='Log to file')
parser.add_argument('--uefi', help='Boot using UEFI', action='store_true', default=False)
parser.add_argument('--no-kvm', help='Disable use of kvm', action='store_true', default=False)
parser.add_argument('--qemu-cmd', help='Only generate QEMU launch command',
                action='store_true', default=False)
parser.add_argument('--cleanup', help='Only cleanup',
                action='store_true', default=False)

args = parser.parse_args()

if not args.agents.isdigit():
    print('Invalid number of agents')
    sys.exit(1)

install_states[0] = False
ready_states[0] = False

for i in range(1, int(args.agents) + 1):
    agents[i] = f'{disk_prefix}-agent{i}.img'
    install_states[i] = False
    ready_states[i] = False

with open('data/defaults.toml') as f:
    vyos_defaults = toml.load(f)

# Setting up logger
log = logging.getLogger()
log.setLevel(logging.DEBUG)

formatter = logging.Formatter('%(levelname)5s - %(message)s')

handler = logging.StreamHandler(sys.stdout)
if args.silent:
    handler.setLevel(logging.ERROR)
elif args.debug:
    handler.setLevel(logging.DEBUG)
else:
    handler.setLevel(logging.INFO)

handler.setFormatter(formatter)
log.addHandler(handler)

if args.logfile:
    filehandler = logging.FileHandler(args.logfile)
    filehandler.setLevel(logging.DEBUG)
    filehandler.setFormatter(formatter)
    log.addHandler(filehandler)

if args.silent:
    output = BytesIO()
else:
    output = sys.stdout.buffer

# Utility functions

class StreamToLogger(object):
    """
    Fake file-like stream object that redirects writes to a logger instance.
    """
    def __init__(self, logger, index=None, log_level=logging.INFO):
        self.logger = logger
        self.log_level = log_level
        self.prefix = f'agent {index}: ' if index else ''
        self.linebuf = b''
        self.ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')

    def write(self, buf):
        self.linebuf += buf
        #print('.')
        while b'\n' in self.linebuf:
            f = self.linebuf.split(b'\n', 1)
            if len(f) == 2:
                self.logger.debug(self.prefix + self.ansi_escape.sub('', f[0].decode(errors="replace").rstrip()))
                self.linebuf = f[1]
            #print(f)

    def flush(self):
        pass

def get_half_cpus():
    """ return 1/2 of the numbers of available CPUs """
    cpu = os.cpu_count()
    if cpu > 1:
        cpu /= 2
    return int(cpu)

def init_tap_network():
    log.info('Creating TAP interfaces...')
    user = pwd.getpwuid(os.getuid())[0]
    for device in ['tap0', 'tap1']:
        subprocess.run(['ip', 'link', 'add', 'br' + device[-1], 'type', 'bridge'])

        subprocess.run(['ip', 'tuntap', 'add', device, 'mode', 'tap', 'user', user])
        subprocess.run(['ip', 'link', 'set', 'dev', device, 'master', 'br' + device[-1]])
        subprocess.run(['ip', 'link', 'set', 'dev', device, 'up'])


        for index, _ in agents.items():
            subprocess.run(['ip', 'tuntap', 'add', f'{device}i{index}', 'mode', 'tap', 'user', user])
            subprocess.run(['ip', 'link', 'set', 'dev', f'{device}i{index}', 'master', 'br' + device[-1]])
            subprocess.run(['ip', 'link', 'set', 'dev', f'{device}i{index}', 'up'])

        subprocess.run(['ip', 'link', 'set', 'dev', 'br' + device[-1], 'up'])
    time.sleep(5)

def cleanup_tap_network():
    log.info('Cleaning up TAP interfaces...')
    user = pwd.getpwuid(os.getuid())[0]
    for device in ['tap0', 'tap1']:
        subprocess.run(['ip', 'link', 'set', 'dev', 'br' + device[-1], 'down'])

        subprocess.run(['ip', 'tuntap', 'del', device, 'mode', 'tap'])

        for index, _ in agents.items():
            subprocess.run(['ip', 'tuntap', 'del', f'{device}i{index}', 'mode', 'tap'])

        subprocess.run(['ip', 'link', 'del', 'br' + device[-1], 'type', 'bridge'])

def get_qemu_cmd(name, index, enable_kvm, enable_uefi, disk_img, iso_img=None):
    kvm = "-enable-kvm"
    cpu = "-cpu host"
    if not enable_kvm:
        kvm = "--no-kvm"
        cpu = ""

    uefi = ""
    if enable_uefi:
        uefi = '-bios /usr/share/OVMF/OVMF_CODE.fd'
        name = f'{name}-UEFI'

    bootindex = '1'
    cdrom = ""
    if iso_img:
        cdrom = f' -boot d' \
                f' -drive file={iso_img},format=raw,if=none,media=cdrom,id=drive-cd1,readonly=on' \
                f' -device ahci,id=achi0' \
                f' -device ide-cd,bus=achi0.0,drive=drive-cd1,id=cd1,bootindex={bootindex}'

        # Set regular harddisk bootindex to 2 as we boot from a CDROM drive
        bootindex = '2'

    # test using half of the available CPUs on the system
    cpucount = get_half_cpus()

    if_suffix = f'i{index}' if index > 0 else ''
    mac_1 = '52:54:00:00:00:%02x' % index
    mac_2 = '52:54:00:00:01:%02x' % index
    cmd = f'qemu-system-x86_64 \
        -name "{name}" \
        -smp sockets=1,cpus={cpucount},cores=1 \
        -cpu host \
        {uefi} \
        -m 2G \
        -vga none \
        -nographic \
        -machine accel=kvm \
        {cpu} \
        {cdrom} \
        {kvm} \
        -netdev tap,id=n0,ifname=tap0{if_suffix},script=no,downscript=no -device virtio-net-pci,netdev=n0,mac={mac_1},romfile="" \
        -netdev tap,id=n1,ifname=tap1{if_suffix},script=no,downscript=no -device virtio-net-pci,netdev=n1,mac={mac_2},romfile="" \
        -device virtio-scsi-pci,id=scsi0 \
        -drive format=raw,file={disk_img},if=none,media=disk,id=drive-hd1,readonly=off \
        -device scsi-hd,bus=scsi0.0,drive=drive-hd1,id=hd1,bootindex={bootindex}'

    return cmd

def gen_disk(name):
    if not os.path.isfile(name):
        log.info(f'Creating Disk image {name}')
        c = subprocess.check_output(['qemu-img', 'create', name, '2G'])
        log.debug(c.decode())
    else:
        log.info(f'Diskimage "{name}" already exists, using the existing one.')

def cleanup_disks():
    log.info(f'Removing disk files')
    try:
        disk_image = f'{disk_prefix}.img'
        if os.path.exists(disk_image):
            os.remove(disk_image)

        for index, disk_img in agents.items():
            if os.path.exists(disk_img):
                os.remove(disk_img)
    except Exception:
        log.error('Exception while removing diskimages!')
        log.error(traceback.format_exc())
        EXCEPTION = 1

def loginVM(c, log, index):
    log.info(f'{index}: Waiting for login prompt')
    c.expect('[Ll]ogin:', timeout=600)
    c.sendline(default_user)
    c.expect('[Pp]assword:')
    c.sendline(default_password)
    c.expect(op_mode_prompt)
    log.info(f'{index}: Logged in!')

def shutdownVM(c, log, index, message=''):
    #################################################
    # Powering off system
    #################################################
    if message:
        log.info(f'{index}: {message}')

    c.sendline('poweroff now')
    log.info(f'{index}: Shutting down virtual machine')
    for i in range(30):
        log.info(f'{index}: Waiting for shutdown...')
        if not c.isalive():
            log.info(f'{index}: VM is shut down!')
            break
        time.sleep(10)
    else:
        tmp = f'{index}: VM Did not shut down after 300sec'
        log.error(tmp)
        raise Exception(tmp)

# Early-quit functions

if args.no_kvm:
    log.error('KVM forced off by command line')
    kvm=False
elif not os.path.exists('/dev/kvm'):
    log.error('KVM not enabled on host, proceeding with software emulation')
    kvm=False
else:
    kvm=True

if args.qemu_cmd:
    disk_image = f'{disk_prefix}.img'
    tmp = get_qemu_cmd(f'TESTVM0', 0, kvm, args.uefi, disk_image, args.iso)
    print(tmp)
    for i, disk_img in agents.items():
        tmp = get_qemu_cmd(f'TESTVM{i}', i, kvm, args.uefi, disk_img, args.iso)
        print(tmp)
    exit(0)

if args.cleanup:
    cleanup_tap_network()
    cleanup_disks()
    exit(0)

if not os.path.isfile(args.iso):
    log.error('Unable to find iso image to install')
    sys.exit(1)

# Install / Boot

def install_system(index, disk_img):
    global EXCEPTION
    global install_states
    try:
        gen_disk(disk_img)

        #################################################
        # Installing image to disk
        #################################################
        log.info(f'Installing system {index}')
        cmd = get_qemu_cmd(f'TESTVM{index}', index, kvm, args.uefi, disk_img, args.iso)
        log.debug(f'{index}: Executing command: {cmd}')
        stl = StreamToLogger(log, index=index if index > 0 else None)
        c = pexpect.spawn(cmd, logfile=stl, timeout=60)

        #################################################
        # Logging into VyOS system
        #################################################

        try:
            c.expect('Automatic boot in', timeout=10)
            c.sendline('')
        except pexpect.TIMEOUT:
            log.warning(f'{index}: Did not find GRUB countdown window, ignoring')

        loginVM(c, log, index)

        #################################################
        # Installing into VyOS system
        #################################################
        log.info(f'{index}: Starting installer')
        c.sendline('install image')
        c.expect('\nWould you like to continue?.*:')
        c.sendline('yes')

        log.info(f'{index}: Partitioning disk')
        c.expect('\nPartition.*:')
        c.sendline('')
        c.expect('\nInstall the image on.*:')
        c.sendline('')
        c.expect(r'\nContinue\?.*:')
        c.sendline('Yes')
        c.expect('\nHow big of a root partition should I create?.*:')
        c.sendline('')

        log.info(f'{index}: Disk(s) partitioned, installing...')
        c.expect('\nWhat would you like to name this image?.*:', timeout=600)
        c.sendline('')
        log.info(f'{index}: Copying files')
        c.expect('\nWhich one should I copy to.*:', timeout=600)
        c.sendline('')
        log.info(f'{index}: Files Copied!')
        c.expect('\nEnter password for user.*:')
        c.sendline(default_user)
        c.expect('\nRetype password for user.*:')
        c.sendline(default_password)

        c.expect('\nWhich drive should GRUB modify the boot partition on.*:')
        c.sendline('')
        c.expect(op_mode_prompt)

        log.info(f'{index}: system installed, shutting down')

        install_states[index] = True

        #################################################
        # Powering down installer
        #################################################
        shutdownVM(c, log, index, 'Shutting down installation system')
        c.close()
    except pexpect.exceptions.TIMEOUT:
        log.error('Timeout waiting for VyOS system')
        log.error(traceback.format_exc())
        EXCEPTION = 1

    except pexpect.exceptions.ExceptionPexpect:
        log.error('Exeption while executing QEMU')
        log.error('Is qemu working on this system?')
        log.error(traceback.format_exc())
        EXCEPTION = 1

def boot_system(index, disk_img):
    global EXCEPTION
    global ready_states
    try:
        #################################################
        # Booting installed system
        #################################################
        log.info(f'{index}: Booting installed system')
        cmd = get_qemu_cmd(f'TESTVM{index}', index, kvm, args.uefi, disk_img)
        log.debug(f'{index}: Executing command: {cmd}')
        stl = StreamToLogger(log, index=index if index > 0 else None)
        c = pexpect.spawn(cmd, logfile=stl)

        #################################################
        # Logging into VyOS system
        #################################################
        try:
            c.expect('The highlighted entry will be executed automatically in', timeout=10)
            c.sendline('')
        except pexpect.TIMEOUT:
            log.warning(f'{index}: Did not find GRUB countdown window, ignoring')

        loginVM(c, log, index)

        #################################################
        # Start/stop config daemon
        #################################################
        c.sendline('sudo systemctl stop vyos-configd.service &> /dev/null')
        c.expect(op_mode_prompt)

        #################################################
        # Basic Configmode/Opmode switch
        #################################################
        log.info(f'{index}: Basic CLI configuration mode test')
        c.sendline('configure')
        c.expect(cfg_mode_prompt)
        c.sendline('exit')
        c.expect(op_mode_prompt)
        c.sendline('show version')
        c.expect(op_mode_prompt)
        c.sendline('show version kernel')
        c.expect(f'{vyos_defaults["kernel_version"]}-{vyos_defaults["architecture"]}-vyos')
        c.expect(op_mode_prompt)
        c.sendline('show version frr')
        c.expect(op_mode_prompt)
        c.sendline('show interfaces')
        c.expect(op_mode_prompt)
        c.sendline('systemd-detect-virt')
        c.expect('kvm')
        c.expect(op_mode_prompt)

        ready_states[index] = True
        test_command = ''

        if index == 0:
            log.info(f'{index}: Waiting for all agents...')
            count = 0
            max_wait = 30
            while not all(v for k,v in ready_states.items()):
                log.info(f'{index}: Still waiting...')
                if count > max_wait:
                    raise Exception(f'Max wait exceeded waiting for agents')
                count += 1
                time.sleep(5)

            test_command = f'/usr/bin/vyos-smoketest-network --agents {args.agents}'
        else:
            test_command = f'/usr/bin/vyos-smoketest-network-agent --agent {index}'
        

        #################################################
        # Executing test-suite
        #################################################
        log.info(f'{index}: Executing VyOS smoketests')
        c.sendline(test_command)
        i = c.expect(['\n +Invalid command:', '\n +Set failed',
                      'No such file or directory', r'\n\S+@\S+[$#]'], timeout=test_timeout)

        if i == 0:
            raise Exception(f'{index}: Invalid command detected')
        elif i == 1:
            raise Exception(f'{index}: Set syntax failed :/')
        elif i == 2:
            tmp = f'{index}: (W)hy (T)he (F)ace? VyOS smoketest not found!'
            log.error(tmp)
            raise Exception(tmp)

        c.sendline('echo EXITCODE:$\x16?')
        i = c.expect(['EXITCODE:0', 'EXITCODE:\d+'])
        if i == 0:
            log.info(f'{index}: Smoketest finished successfully!')
            pass
        elif i == 1:
            log.error(f'{index}: Smoketest failed :/')
            raise Exception(f"{index}: Smoketest-failed, please look into debug output")

        shutdownVM(c, log, index, 'Powering off system')
        c.close()
    except pexpect.exceptions.TIMEOUT:
        log.error(f'{index}: Timeout waiting for VyOS system')
        log.error(traceback.format_exc())
        EXCEPTION = 1
    except pexpect.exceptions.ExceptionPexpect:
        log.error(f'{index}: Exeption while executing QEMU')
        log.error(f'{index}: Is qemu working on this system?')
        log.error(traceback.format_exc())
        EXCEPTION = 1

# Start

try:
    threads = {}

    # Bring up VM bridge TAP interfaces
    init_tap_network()

    disk_image = f'{disk_prefix}.img'
    t = threading.Thread(target=install_system, args=[0, disk_image])
    t.start()
    threads[0] = t

    for index, disk_img in agents.items():
        t = threading.Thread(target=install_system, args=[index, disk_img])
        t.start()
        threads[index] = t

    while any(v.is_alive() for k,v in threads.items()):
        time.sleep(5)

    if not all(v for k,v in install_states.items()):
        raise Exception('Install failed on one or more agents: ' + str(install_states))

    t = threading.Thread(target=boot_system, args=[0, disk_image])
    t.start()
    threads[0] = t

    for index, disk_img in agents.items():
        t = threading.Thread(target=boot_system, args=[index, disk_img])
        t.daemon = True
        t.start()
        threads[index] = t

    count = 0
    while any(v.is_alive() for k,v in threads.items()):
        if not threads[0].is_alive():
            if count > 6:
                print("Note: Master process finished, but agent(s) still hanging.")
                break
            count += 1
        time.sleep(5)
except Exception:
    log.error('Unknown error occured while VyOS!')
    traceback.print_exc()
    EXCEPTION = 1

#################################################
# Cleaning up
#################################################
log.info("Cleaning up")

cleanup_tap_network()

if not args.keep:
    cleanup_disks()

if EXCEPTION:
    log.error('Hmm... system got an exception while processing.')
    log.error('The ISO image is not considered usable!')
    sys.exit(1)
